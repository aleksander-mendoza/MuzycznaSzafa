 //
//  CoreDataRelatEntry.swift
//  MuzSzafaShared
//
//  Created by Alagris on 27/03/2018.
//  Copyright Â© 2018 alagris. All rights reserved.
//
import CoreData
public typealias CellRelatToManyEntry = (mos:NSSet,attr:CoreDataRelatEntry)
public typealias CellRelatEntry = (mo:NSManagedObject?,attr:CoreDataRelatEntry)
public typealias CellRelatListEntry = (mo:NSManagedObject?,relat:CoreDataRelatEntry)
public typealias RelatEntry = (key:String,value:NSRelationshipDescription)
 open class CoreDataRelatEntry:CoreDataAttr{
    
    
    public lazy var serializer: CoreDataSerializer = newCoreDataSerializer(from: self)
    
    public var options: PropertyOptionDict
    
	public weak var parent: CoreDataEntity!
		
    public var isPrimaryKey: Bool
	
	public var hideFromUser: Bool = false
    
    public let rawType: NSAttributeType = .objectIDAttributeType
    
    public let type: PropertyType
	
    public var isAutogenerated: Bool{
        get{
            return false
        }
    }
    public var isFiltrable: Bool
    
    public var name: String
    
    public var vis: PropertyVisibility
    
    public var isToMany:Bool
    
    public let destEntName:String!
    public var destEnt:CoreDataEntity{
        get{
            return parent.cache.find(destEntName)!
        }
    }
	
	public var description:NSRelationshipDescription
	
	public var inverseDescription:NSRelationshipDescription{
		get{
			return description.inverseRelationship!
		}
	}
	
	public var inverseAttr:CoreDataRelatEntry{
		get{
			let inv = inverseDescription
			let invEnt = parent.cache.find(inv.entity)!
			return invEnt.find(relat: inv)!
		}
	}
	
    public convenience init(dict entry: RelatEntry,
                            json:[String:String],
                            _ src:CoreDataCache){
        self.init(value:entry.value,json:json,src)
    }
	
	
    public init(value:NSRelationshipDescription,
                json:[String:String],
                _ src:CoreDataCache){
        
        isToMany = value.isToMany
        name = CoreDataRelatEntry.parseName(json: json)
		description = value
        destEntName = value.destinationEntity?.name
        vis = CoreDataRelatEntry.parseVisibility(json: json)
        isPrimaryKey = CoreDataAttrEntry.parseIsPrimaryKey(json: json)
		hideFromUser = CoreDataAttrEntry.parseHideFromUser(json: json)
        let nameCopy = self.name
        if vis == .external{
            fatalError("Illegal configuration! \"\(nameCopy)\" has external visibility but is of type relat!")
        }
        options = CoreDataRelatEntry.parseOptions(json: json,type:.relat)
        isFiltrable = CoreDataAttrEntry.parseIsFiltrable(json: json)
        type = CoreDataRelatEntry.parseType(json:json,rawType:rawType)
		if isToMany{
			if type != .relatList && type != .relatToMany{
				fatalError("type of \"\(name)\" must be \"relatList\" or \"relatToMany\" (found \(type) instead)")
			}
		}else{
			if type != .relat{
				fatalError("type of \"\(name)\" must be \"relat\" (found \(type) instead)")
			}
		}
        if CoreDataAttrEntry.parseIsAutogenerated(json: json){
            fatalError("relat attribute (\(name)) cannot be autogenerated!")
        }
		if value.inverseRelationship == nil{
			fatalError("relat attribute (\(name)) has no inverse relationship!")
		}
    }
    public init(clone:CoreDataRelatEntry){
		description = clone.description
        parent = clone.parent
        isToMany = clone.isToMany
        name = clone.name
        destEntName = clone.destEntName
        vis = clone.vis
        isPrimaryKey = clone.isPrimaryKey
        options = clone.options
        isFiltrable = clone.isFiltrable
		type = clone.type
		
    }
    public func makeFilter() -> CoreDataFilter {
        let clone = CoreDataRelatEntry(clone:self)
        clone.options[.editable] = true
        let f = type.makeFilter(for: clone)
        f.isEnabled = isFiltrable
        return f
    }
	
	public func set(for mo: NSManagedObject, val: Any?) {
		assert(mo.entity == parent.description, "expected \(parent.name.or()) but was \(mo.entity.name.or())")
		if isToMany{
			guard let val = val else{return}
			let set = mo.mutableSetValue(forKey: name)
			if let valAsSet = val as? NSSet{
				set.addObjects(from: valAsSet.allObjects)
			}else if let valAsList = val as? [Any]{
				set.addObjects(from: valAsList)
			}else{
				set.add(val)
			}
		}else{
			
			assert(mo.entity.relationshipsByName[name] != nil,"\(mo.entity.name.or()) doesn't contain \(name)")
			mo.setValue(val, forKey: name)
		}
	}
}

