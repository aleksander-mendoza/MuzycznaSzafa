//
//  CoreDataEntityDeserializers.swift
//  MuzSzafaShared
//
//  Created by Alagris on 13/06/2018.
//  Copyright Â© 2018 alagris. All rights reserved.
//

import CoreData
public extension CoreDataEntity{
    public func deserializeAttrs(names:[String])->[CoreDataAttr?]{
        var attrs = [CoreDataAttr?]()
        for name in names{
            let attr = find(attr: name)
            attrs += attr
        }
        return attrs
    }
    
    public func set(values:[String],for attributes:[CoreDataAttr?]) throws{
        let pkIndex = attributes.index(){$0?.isPrimaryKey ?? false}
        guard let pki = pkIndex else{
            return
        }
        let pkAttr = attributes[pki]!
        try set(values: values, for: attributes,pkIndex:pki,pkAttr:pkAttr)
        
    }
	public enum PrimaryKeyException: Error {
		case cannotAutogenerateKey(String)
	}

    public func set(values:[String],
                    for attributes:[CoreDataAttr?],
                    pkIndex:Int,
                    pkAttr:CoreDataAttr!) throws{
		if values.isEmpty {return}
		
		func loadValues(mo:NSManagedObject){
			assert(values.count==attributes.count,"Mismatched sizes! \(values.count) != \(attributes.count)")
			for (val,attr) in zip(values,attributes) where attr != nil && !attr!.isPrimaryKey{
				set(serialized: val, for: attr!,with:mo)
			}
		}
		if pkIndex < 0{
			guard let mo = newAutogenerated() else{
				throw PrimaryKeyException.cannotAutogenerateKey("Primary key is not included in read values and neither can be generated automatically!")
			}
			loadValues(mo:mo)
		}else{
			let pkStr = values[pkIndex]
			guard let pk = pkAttr.serializer.deserialize(any: pkStr) else{
				assertionFailure("Failed to deserialize entry for type \(name ?? "?") with primary key=\(pkStr)")
				return
			}
			let mo = ensureExists(pk)
			loadValues(mo:mo)
		}
		
    }
    public func set(serialized value:String,for attr:CoreDataAttr,with mo:NSManagedObject){
//        if attr.type == .relat{
//			if value == ""{
//				return
//			}
//            let a = attr as! CoreDataRelatEntry
//            let relatPk = a.destEnt.primaryKeyAttr
//            let foreignKey = relatPk.serializer.deserialize(any: value)
//            if foreignKey == nil{
//                return
//            }
//            let relatMO = a.destEnt.ensureExists(mainAttrVal: foreignKey!)
//            if relatMO == nil{
//                return
//            }
//            a.set(for: mo, val: relatMO!)
//		}else if attr.type == .relatToMany{
//			if value == ""{
//				return
//			}
//			let a = attr as! CoreDataRelatEntry
//			let relatPk = a.destEnt.primaryKeyAttr
//			let foreignKeys = relatPk.serializer.deserialize(any: value)
//			if foreignKeys == nil{
//				return
//			}
//			let relatMO = a.destEnt.ensureExists(mainAttrVal: foreignKey!)
//			if relatMO == nil{
//				return
//			}
//			a.set(for: mo, val: relatMO!)
//		}else {
            attr.set(for:mo,serialized:value)
//        }
    }
}
