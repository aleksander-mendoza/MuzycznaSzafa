////
////  CoreDataEntManip.swift
////  MuzSzafaShared
////
////  Created by Alagris on 01/05/2018.
////  Copyright Â© 2018 alagris. All rights reserved.
////
//
//import CoreData
//
//public protocol CoreDataEntManip:CoreDataControlledManip{
//    var attrs:[CoreDataAttr]{get}
//    var description:NSEntityDescription{get}
//    var primaryKeyAttr:CoreDataAttr{get}
//}
//
//public extension CoreDataEntManip{
//    func autogenerateNew() -> NSManagedObject? {
//        guard let val = primaryKeyAttr.autogenerateUnique() else{
//            return nil
//        }
//        return autogenerateNew(mainAttrVal: val)
//    }
//    func autogenerateNew(mainAttrVal: Any) -> NSManagedObject? {
//        guard count(mainAttrVal: mainAttrVal) == 0 else{
//            return nil
//        }
//        guard let mo = getNew(mainAttrVal:mainAttrVal) else {
//            return nil
//        }
//        for a in attrs where a.isAutogenerated && !a.isPrimaryKey{
//            _ = a.autogenerate(mo:mo)
//        }
//        return mo
//    }
//    func autogenerateNew(mainAttrVal: Any,relats:[NSManagedObject]) -> NSManagedObject?{
//        let mo = autogenerateNew(mainAttrVal: mainAttrVal)
//        if let m = mo{
//            set(relats: relats, for: m)
//        }
//        return mo
//    }
//    func autogenerateNew(relats:[NSManagedObject]) -> NSManagedObject?{
//        let mo = autogenerateNew()
//        if let m = mo{
//            set(relats: relats, for: m)
//        }
//        return mo
//    }
//    func ensureExists(mainAttrVal:Any,relats:[NSManagedObject])->NSManagedObject?{
//        if let mo = ensureExists(mainAttrVal: mainAttrVal){
//            set(relats: relats, for: mo)
//            return mo
//        }
//        return nil
//    }
//
//
//    func set(relats:[NSManagedObject],for mo:NSManagedObject){
//        if mo.entity != description{
//            assertionFailure("Passed NSManagedObject is of type \(mo.entity.name ?? "?") but should be \(description.name ?? "?")")
//			return
//        }
//        for relat in relats{
//            if let r = findRelatAttrBy(mo: relat){
//                r.set(for: mo, val: relat)
//			}
//        }
//    }
//
//    func selectByRelats(mos:[NSManagedObject],
//                        limit:Int=0,
//                        sort:[NSSortDescriptor]?=nil)->[NSManagedObject]?{
//        return select(filterByRelats(mos: mos), limit: limit,sort:sort)
//    }
//
//    func filterByRelats(mos:[NSManagedObject])->NSPredicate{
//        var format = [String]()
//        var args = [Any]()
//        for mo in mos{
//            if let relat = findRelatAttrBy(mo: mo){
//				if relat.isToMany{
//					format += "ANY %K == %@"
//					args += [relat.name, mo]
//				}else{
//					format += "%K == %@"
//					args += [relat.name, mo]
//				}
//            }
//        }
//        let str = format.joined(separator: " && ")
//        return NSPredicate(format: str, argumentArray: args)
//    }
//    func findRelatAttrBy(ent:NSEntityDescription)->CoreDataRelatEntry?{
//        for attr in attrs{
//            if let relat = attr as? CoreDataRelatEntry{
//                if relat.destEnt.description == ent{
//                    return relat
//                }
//            }
//        }
//		assertionFailure("relationship to entity \(ent.name ?? "???") not found!")
//        return nil
//    }
//    func findRelatAttrBy(mo:NSManagedObject)->CoreDataRelatEntry?{
//        return findRelatAttrBy(ent: mo.entity)
//    }
//    func find<S>(attr name:S)->CoreDataAttr? where S:StringProtocol{
//        for attr in attrs{
//            if name.elementsEqual(attr.name){
//                return attr
//            }
//        }
//        return nil
//    }
//	func find(relat desc:NSRelationshipDescription)->CoreDataRelatEntry?{
//		for attr in attrs{
//			if let r = attr as? CoreDataRelatEntry,
//				desc == r.description{
//				return r
//			}
//		}
//		return nil
//	}
//}
