//
//  TablePair.swift
//  MuzSzafaMacFramework
//
//  Created by Alagris on 07/04/2018.
//  Copyright Â© 2018 alagris. All rights reserved.
//

import Foundation
import MuzSzafaShared
open class TablePair{
	public let properties:CoreDataTable
	public let list:[NSEntityDescription:EntitiesTableView]
    public let cntx:CoreContext
    open var onChangeImpl:EntPropertyObeserver?
	open var onSelectionImpl:((_ ent:NSEntityDescription)->Void)?
	
	open var selectedEnt:CoreDataEntity?{
		get{
			return properties.ent
		}
	}
	
	open var selectedEntDesc:NSEntityDescription?{
		get{
			return selectedEnt?.description
		}
	}
	
	open var selectedList:EntitiesTableView?{
		get{
			if let d = selectedEnt?.description{
				return list[d]
			}
			return nil
		}
	}
	
	open var selectedMO:NSManagedObject?{
		get{
			guard let ent = selectedEntDesc else{return nil}
			return selectedMoFor(ent: ent)
		}
	}
	
	open func selectedMoFor(ent:NSEntityDescription)->NSManagedObject?{
		return list[ent]?.selectedObj
	}
	public convenience init?(prop properties:CoreDataTable,
							 list:EntitiesTableView,
							 ent:String,
							 cntx:CoreContext){
		self.init(prop:properties,
				  list:list,
				  ent:cntx.entity(for: ent)!,
				  cntx:cntx)
	}
	
	public convenience init?(prop properties:CoreDataTable,
							 list:EntitiesTableView,
							 ent:NSEntityDescription,
							 cntx:CoreContext){
		self.init(prop:properties,
				  list:[ent:list],
				  cntx:cntx)
	}
    public init?(prop properties:CoreDataTable,
                list:[NSEntityDescription:EntitiesTableView],
				cntx:CoreContext){
        self.properties = properties
        self.list = list
        self.cntx = cntx
		for (ent,l) in list{
			l.reloadData(ent: cntx.cache.find(ent))
			l.selectionCallback = {
				[weak self] in
				self!.onSelectionImpl?(ent)
				self!.loadSelected(ent:ent)
			}
		}
    }
	
	public func loadNew(for ent:NSEntityDescription){
		assert(list.keys.contains(ent))
		if let e = cntx.cache.find(ent){
			loadNew(for: e)
		}else{
			assertionFailure()
		}
	}
	
	public func loadNew(for ent:CoreDataEntity){
        load(mo:ent.newAutogenerated())
    }
	private func loadSelected(ent:NSEntityDescription){
		if let mo = list[ent]?.selectedObj{
			loadProperties(for: mo)
		}
	}
	private func loadProperties(for mo:NSManagedObject?){
		guard let mo = mo else{return}
		if properties.obj == mo{return}
		properties.setLocalizedTitle(title: mo.entity.name ?? "")
		let ent = cntx.cache.find(mo.entity)
        properties.reloadData(ent: ent, obj: mo)
		properties.onChangeImpl = {
			[weak self] val,attr,event in
			self!.selectedList?.reloadDataAtSelectedRow(attr: attr)
			switch attr.type{
			case .relat:
				fallthrough
			case .relatToMany:
				if let press = event as? PropertyTableEntryRelatPressEvent{
					if let mo = press.mo{
						self!.load(mo: mo)
					}
				}
			case .relatList:
				fallthrough
			case .moList:
				if let select = event as? PropertyTableEntryMOSelectEvent{
					self!.load(mo: select.mo)
				}
			default:
				break
			}
			self!.onChangeImpl?(val,attr, event)
		}
    }
	public func select(mo:NSManagedObject?){
		if let ent = mo?.entity, let l = list[ent]{
			assert(l.ent?.description==ent)
			l.reloadData()
			l.selectedObj = mo
		}
	}
    public func load(mo:NSManagedObject?){
		select(mo: mo)
		loadProperties(for: mo)
    }
    open func update(filter group:EntFilterGroup){
		for filter in group.all{
        	update(filter: filter)
		}
    }
    open func update(filter:EntFilter){
        list[filter.parent.description]?.update(filter: filter)
    }
    open func update(sort group:EntSortGroup){
		for sort in group.all{
        	update(sort: sort)
		}
    }
    open func update(sort:EntSort){
        list[sort.ent.description]?.update(sort: sort)
    }
	open func removeAllFilters(){
		for (_,l) in list{
			l.removeFilters()
		}
	}
	open func removeFilters(ent:NSEntityDescription){
        list[ent]?.removeFilters()
    }
}


private extension EntitiesTableView{
	func update(filter:EntFilter){
		let new = filter.pred
		if new == nil{
			
			if self.pred == nil{
				return
			}
			self.pred = nil
		}else{
			guard let ent = ent else{
				assertionFailure()
				return
			}
			self.pred = SafePredicate(ent: ent, expr: new!)
		}
		self.reloadData()
	}
	
	func update(sort:EntSort){
		let new = sort.sort
		if new == nil && self.sort == nil{
			return
		}
		self.sort = new
		reloadData()
	}
	func removeFilters(){
		pred = nil
		reloadData()
	}
	func reloadDataAtSelectedRow(attr:CoreDataAttr){
		reloadData(row: selectedRow, attr: attr.name)
	}
}
